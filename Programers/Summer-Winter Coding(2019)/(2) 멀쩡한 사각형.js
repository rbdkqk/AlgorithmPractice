/* 멀쩡한 사각형 (2020.09.16) 
  
  'Summer-Winter Coding(2019)' 파트, 난이도 2단계  -  50분 내외 소요 (실패함)
    => 아직 테스트케이스 2개가 통과되지 않은 상태로 일단 올리는 것임... (1번, 10번 실패)
    

  1. 문제 설명
    
    가로 길이가 Wcm, 세로 길이가 Hcm인 직사각형 종이가 있습니다. 
    종이에는 가로, 세로 방향과 평행하게 격자 형태로 선이 그어져 있으며, 모든 격자칸은 1cm x 1cm 크기입니다. 
    이 종이를 격자 선을 따라 1cm × 1cm의 정사각형으로 잘라 사용할 예정이었는데, 누군가가 이 종이를 대각선 꼭지점 2개를 잇는 방향으로 잘라 놓았습니다. 
    그러므로 현재 직사각형 종이는 크기가 같은 직각삼각형 2개로 나누어진 상태입니다. 
    새로운 종이를 구할 수 없는 상태이기 때문에, 이 종이에서 원래 종이의 가로, 세로 방향과 평행하게 1cm × 1cm로 잘라 사용할 수 있는 만큼만 사용하기로 하였습니다.
    가로의 길이 W와 세로의 길이 H가 주어질 때, 사용할 수 있는 정사각형의 개수를 구하는 solution 함수를 완성해 주세요.


  2. 제한사항

    W, H : 1억 이하의 자연수


  3. 입출력 예
    
    w : 8
    h : 12
    result : 80

      가로가 8, 세로가 12인 직사각형을 대각선 방향으로 자르면 총 16개 정사각형을 사용할 수 없게 됩니다. 
      원래 직사각형에서는 96개의 정사각형을 만들 수 있었으므로, 96 - 16 = 80 을 반환합니다.
    

  4. 복잡도 계산
    - 시간복잡도 : O(1) 또는 O(n)  - 
        주어져 있는 가로세로 값만 가지고 계산하므로 O(1) 같다.
        다만, 최대공약수를 구하는 함수 부분에서는, 1부터 시작해서 w와 h 중 더 작은 값만큼 돌리기 때문에, 이걸 감안하면 O(n)

    - 공간복잡도 : O(1)  - 
        단순히 숫자를 계산하는 정도이므로, 상수일 듯

*/

function solution(w, h) {
  var answer = 1; // 이걸 왜 1을 주고 시작할까?

  if (w === 1 || h === 1 || w * h === 2) {
    return 0;
  }

  let originalSquares = w * h; // 원래 쓸 수 있었던, 전체 모든 사각형들의 개수 합

  if (w === h) {
    return originalSquares - w;
  } else {
    // 최대공약수가 도움이 될 듯
    // 전체 개수 - (한 덩어리 안의 개수 안에서, 못쓰게 된 개수 * 최대공약수)
    // '96' - (한 덩어리 6 중에서, 못쓰게 된 것은 '4개' * 최대공약수 '4')

    let gcd = getGCD(w, h); // 최대공약수를 구해놓고 : 4
    let smallW = w / gcd;
    let smallH = h / gcd;
    let smallSquares = smallW * smallH; // 작게 쪼갠, 선이 지나간 조각 안의 사각형 개수 : 6

    /* 고민한  흔적
      
          2 5 => 10개 중에, 6개 죽고 4개 남음 =>  4/10 살아남음
          2 3 => 6개 중에, 4개 죽고 2개 남음 =>  2/6 살아남음
          3 5 => 15개 중에, 7개 죽고 8개 남음
          살아남은 사각형 수 = smallSquares - ()
      
      */

    return originalSquares - (w + h - gcd);
  }

  /* 질문글 목록에서 찾은 해결법임...
  
      우선 w와 h가 공약수가 있다면 문제를 공약수를 나눈 w' 와 h'로 축소시킬수있습니다.

      w'와 h'가 서로소라 가정했을때 대각선은 반대쪽 코너에 도달하기전 w'-1 세로선과 h'-1 가로선을 지나고,
      지날때마다 새로운 정사각형이 추가됩니다. 

      그래서 첫 정사각형을 포함 1 + (w'-1) + (h'-1) = w' + h' - 1개의 정사각형을 지나게 되므로,
      공약수를 다시 곱해주면 w + h - gcd(w,h)개의 정사각형을 지나는것을 찾을수있습니다.

  */

  return answer; // 문제에서 주어진 값인데, 쓰지는 않았음
}

// 최대공약수를 얻기 위한 함수
function getGCD(a, b) {
  let gcd = 1;
  for (let i = 1; i < Math.min(a, b); i++) {
    if (a % i === 0 && b % i === 0) {
      gcd = i;
    }
  }
  return gcd;
}

/* 기록해 둘 사항

  예시 문제에서 최대공약수를 활용해야 하는건가? 하는 생각을 해 봤음 -> 시도했으나 막혔음

  기울기를 활용해야 하지 않나? 라는 생각도 해 봄

  아직 테스트케이스 2개가 통과되지 않은 상태로 일단 올리는 것임... (1번, 10번 실패)

*/
